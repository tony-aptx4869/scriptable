{
  "always_run_in_app" : true,
  "icon" : {
    "color" : "blue",
    "glyph" : "terminal"
  },
  "name" : "Terminal",
  "script" : "\/********************************************\n * Scriptable App script\n * Name: Terminal\n * Coding: UTF-8\n * @ Tony Chang\n * Copyright (c) 1994-2021 Tony Chang \\\n * https:\/\/github.com\/tony-aptx4869 \\\n * All Rights Reserved.\n ********************************************\/\n\n\/********************************************\n * Constants and Configurations\n ********************************************\/\n\n\/\/ NOTE: This script uses the Cache script\n\/\/ https:\/\/github.com\/tony-aptx4869\/scriptable\/blob\/main\/Cache.scriptable\n\/\/ Make sure to add the Cache script in \\\n\/\/ Scriptable as well!\n\n\/\/ TODO: PLEASE SET THESE VALUES\nconst NAME = 'TODO';\n\/\/ Vist this website \\\n\/\/ https:\/\/home.openweathermap.org\/api_keys\n\/\/ to get WEATHER_API_KEY (account needed)\nconst WEATHER_API_KEY = 'TODO';\nconst WORK_CALENDAR_NAME = 'TODO';\nconst PERSONAL_CALENDAR_NAME = 'TODO';\n\n\/\/ Cache keys and default location\nconst CACHE_KEY_LAST_UPDATED = 'last_updated';\nconst CACHE_KEY_LOCATION = 'Beijing';\nconst DEFAULT_LOCATION = { latitude: 39.908901, longitude: 116.397501 };\n\n\/\/ Font name and size\nconst FONT_NAME = 'Menlo';\nconst FONT_SIZE = 12;\n\n\/\/ Colors\nconst COLORS = {\n  bg0: '#29323C',\n  bg1: '#1C1C1C',\n  personalCalendar: '#5BD2F0',\n  workCalendar: '#9D90FF',\n  weather: '#FDFD97',\n  location: '#EF0808',\n  deviceStats: '#7AE7B9',\n  battery: '#2AA876',\n  yearProgress: '#F19C65'\n};\n\n\/\/ Whether or not to use a background \\\n\/\/ image for the widget (if false, use \\\n\/\/ gradient color)\nconst USE_BACKGROUND_IMAGE = false;\n\n\/********************************************\n * Initial Setups\n ********************************************\/\n\n\/**\n * Convenience function to add days to a Date.\n * \n * @param {*} days The number of days to add\n *\/ \n Date.prototype.addDays = function(days) {\n  var date = new Date(this.valueOf());\n  date.setDate(date.getDate() + days);\n  return date;\n};\n\n\/\/ Import and setup Cache\nconst Cache = importModule('Cache');\nconst cache = new Cache('terminalWidget');\n\n\/\/ Fetch data and create widget\nconst data = await fetchData();\nconst widget = createWidget(data);\n\n\/\/ Set background image of widget, if flag is true\nif (USE_BACKGROUND_IMAGE) {\n  \/\/ Determine if our image exists and when it was saved.\n  const files = FileManager.local();\n  const path = files.joinPath(files.documentsDirectory(), 'terminal-widget-background');\n  const exists = files.fileExists(path);\n\n  \/\/ If it exists and we're running in the widget, use photo from cache\n  if (exists && config.runsInWidget) {\n    widget.backgroundImage = files.readImage(path);\n\n  \/\/ If it's missing when running in the widget, use a gradient black\/dark-gray background.\n  } else if (!exists && config.runsInWidget) {\n    const bgColor = new LinearGradient();\n    bgColor.colors = [new Color(\"#29323c\"), new Color(\"#1c1c1c\")];\n    bgColor.locations = [0.0, 1.0];\n    widget.backgroundGradient = bgColor;\n\n  \/\/ But if we're running in app, prompt the user for the image.\n  } else if (config.runsInApp){\n    const img = await Photos.fromLibrary();\n    widget.backgroundImage = img;\n    files.writeImage(path, img);\n  }\n}\n\nif (config.runsInApp) {  \n  widget.presentMedium();\n}\n\nScript.setWidget(widget);\nScript.complete();\n\n\/********************************************\n * Main Functions (Widget and Data-Fetching)\n ********************************************\/\n\n\/**\n * Main widget function.\n * \n * @param {} data The data for the widget to display\n *\/\nfunction createWidget(data) {\n  console.log(`Creating widget with data: ${JSON.stringify(data)}`);\n\n  const widget = new ListWidget();\n  const bgColor = new LinearGradient();\n  bgColor.colors = [new Color(COLORS.bg0), new Color(COLORS.bg1)];\n  bgColor.locations = [0.0, 1.0];\n  widget.backgroundGradient = bgColor;\n  widget.setPadding(10, 15, 15, 10);\n\n  const stack = widget.addStack();\n  stack.layoutVertically();\n  stack.spacing = 4;\n  stack.size = new Size(320, 0);\n\n  \/\/ Line 0 - Last Login\n  const timeFormatter = new DateFormatter();\n  timeFormatter.locale = \"en\";\n  timeFormatter.dateFormat = \"HH:mm, MMM d, y\";\n  \/\/timeFormatter.useNoDateStyle();\n  \/\/timeFormatter.useShortTimeStyle();\n\n  const lastLoginLine = stack.addText(`Last login: ${timeFormatter.string(new Date())} (ã¥ï½¡â—•â€¿â€¿â—•ï½¡)ã¥`);\n  lastLoginLine.textColor = Color.white();\n  lastLoginLine.textOpacity = 0.7;\n  lastLoginLine.font = new Font(FONT_NAME, FONT_SIZE);\n\n  \/\/ Line 1 - Input\n  const inputLine = stack.addText(`${NAME}@iPhone:~$ showinfo`);\n  inputLine.textColor = Color.white();\n  inputLine.font = new Font(FONT_NAME, FONT_SIZE);\n\n  \/\/ Line 2 - Next Personal Calendar Event\n  const nextPersonalCalendarEventLine = stack.addText(`ðŸ  | ${getCalendarEventTitle(data.nextPersonalEvent, false)}`);\n  nextPersonalCalendarEventLine.textColor = new Color(COLORS.personalCalendar);\n  nextPersonalCalendarEventLine.font = new Font(FONT_NAME, FONT_SIZE);\n\n  \/\/ Line 3 - Next Work Calendar Event\n  const nextWorkCalendarEventLine = stack.addText(`ðŸ‘¨ðŸ»â€ðŸ’» | ${getCalendarEventTitle(data.nextWorkEvent, true)}`);\n  nextWorkCalendarEventLine.textColor = new Color(COLORS.workCalendar);\n  nextWorkCalendarEventLine.font = new Font(FONT_NAME, FONT_SIZE);\n\n  \/\/ Line 4 - Weather\n  const weatherLine = stack.addText(`${data.weather.icon} | ${data.weather.temperature}Â° (${data.weather.high}Â°\/${data.weather.low}Â°), ${data.weather.description}, feels like ${data.weather.feelsLike}Â°`);\n  weatherLine.textColor = new Color(COLORS.weather);\n  weatherLine.font = new Font(FONT_NAME, FONT_SIZE);\n  \n  \/\/ Line 5 - Location\n  \/\/ const locationLine = stack.addText(`ðŸ“ | ${data.weather.location}`);\n  const locationLine = stack.addText(`ðŸ“ | Beijing, Mainland PRC`);\n  locationLine.textColor = new Color(COLORS.location);\n  locationLine.font = new Font(FONT_NAME, FONT_SIZE);\n\n  \/\/ Line 6 - Bettery Level\n  const batteryLine = stack.addText(`${Device.isCharging() ? 'âš¡ï¸' : 'ðŸ”‹'} | ${renderBattery()} Bettery`)\n  batteryLine.textColor = new Color(COLORS.battery)\n  batteryLine.font = new Font(FONT_NAME, FONT_SIZE);\n\n  \/\/ Line 7 - Year Progress\n  const yearProgressLine = stack.addText(`â³ | ${renderYearProgress()} Year Left`)\n  yearProgressLine.textColor = new Color(COLORS.yearProgress)\n  yearProgressLine.font = new Font(FONT_NAME, FONT_SIZE);\n\n  return widget;\n}\n\n\/**\n * Fetch pieces of data for the widget.\n *\/\nasync function fetchData() {\n  \/\/ Get the weather data\n  const weather = await fetchWeather();\n\n  \/\/ Get next work\/personal calendar events\n  const nextWorkEvent = await fetchNextCalendarEvent(WORK_CALENDAR_NAME);\n  const nextPersonalEvent = await fetchNextCalendarEvent(PERSONAL_CALENDAR_NAME);\n\n  \/\/ Get last data update time (and set)\n  const lastUpdated = await getLastUpdated();\n  cache.write(CACHE_KEY_LAST_UPDATED, new Date().getTime());\n\n  return {\n    weather,\n    nextWorkEvent,\n    nextPersonalEvent,\n    device: {\n      battery: Math.round(Device.batteryLevel() * 100),\n      brightness: Math.round(Device.screenBrightness() * 100),\n    },\n    lastUpdated,\n  };\n}\n\nfunction renderBattery() {\n    const batteryLevel = data.device.battery \/ 100\n    \/\/ console.log(`Bettery Level: ${batteryLevel}`);\n    const used = 'â–“'.repeat(Math.floor(batteryLevel * 24))\n    const left = 'â–‘'.repeat(24 - used.length)\n    return `${used}${left} ${Math.floor(batteryLevel * 100)}%`\n}\n\nfunction renderYearProgress() {\n    const now = new Date()\n    const start = new Date(now.getFullYear(), 0, 1) \/\/ Start of this year\n    const end = new Date(now.getFullYear() + 1, 0, 1) \/\/ End of this year\n    const progress = (end - now) \/ (end - start)\n    const used = 'â–‘'.repeat(Math.floor((1 - progress) * 24))\n    const left = 'â–“'.repeat(24 - used.length)\n    return `${used}${left} ${Math.floor(progress * 100)}%`\n}\n\n\/********************************************\n * Helper Functions\n ********************************************\/\n\n\/\/-------------------------------------\n\/\/ Weather Helper Functions\n\/\/-------------------------------------\n\n\/**\n * Fetch the weather data from Open Weather Map\n *\/\nasync function fetchWeather() {\n  let location = await cache.read(CACHE_KEY_LOCATION);\n  if (!location) {\n    try {\n      Location.setAccuracyToThreeKilometers();\n      location = await Location.current();\n    } catch(error) {\n      location = await cache.read(CACHE_KEY_LOCATION);\n    }\n  }\n  if (!location) {\n    location = DEFAULT_LOCATION;\n  }\n  const url = \"https:\/\/api.openweathermap.org\/data\/2.5\/onecall?lat=\" + location.latitude + \"&lon=\" + location.longitude + \"&exclude=minutely,hourly,alerts&units=imperial&lang=en&appid=\" + WEATHER_API_KEY;\n  const address = await Location.reverseGeocode(location.latitude, location.longitude);\n  const data = await fetchJson(url);\n\n  const cityState = `${address[0].postalAddress.city}, ${address[0].postalAddress.state}`;\n\n  if (!data) {\n    return {\n      location: cityState,\n      icon: 'â“',\n      description: 'Unknown',\n      temperature: '?',\n      wind: '?',\n      high: '?',\n      low: '?',\n      feelsLike: '?',\n    }\n  }\n\n  const currentTime = new Date().getTime() \/ 1000;\n  const isNight = currentTime >= data.current.sunset || currentTime <= data.current.sunrise\n\n  return {\n    location: cityState,\n    icon: getWeatherEmoji(data.current.weather[0].id, isNight),\n    description: data.current.weather[0].main,\n    temperature: Math.round((data.current.temp - 32) \/ 1.8),\n    wind: Math.round(data.current.wind_speed),\n    high: Math.round((data.daily[0].temp.max - 32) \/ 1.8),\n    low: Math.round((data.daily[0].temp.min - 32) \/ 1.8),\n    feelsLike: Math.round((data.current.feels_like - 32) \/ 1.8),\n  }\n}\n\n\/**\n * Given a weather code from Open Weather Map, determine the best emoji to show.\n * \n * @param {*} code Weather code from Open Weather Map\n * @param {*} isNight Is `true` if it is after sunset and before sunrise\n *\/\nfunction getWeatherEmoji(code, isNight) {\n  if (code >= 200 && code < 300 || code == 960 || code == 961) {\n    return \"â›ˆ\"\n  } else if ((code >= 300 && code < 600) || code == 701) {\n    return \"ðŸŒ§\"\n  } else if (code >= 600 && code < 700) {\n    return \"â„ï¸\"\n  } else if (code == 711) {\n    return \"ðŸ”¥\" \n  } else if (code == 800) {\n    return isNight ? \"ðŸŒ•\" : \"â˜€ï¸\" \n  } else if (code == 801) {\n    return isNight ? \"â˜ï¸\" : \"ðŸŒ¤\"  \n  } else if (code == 802) {\n    return isNight ? \"â˜ï¸\" : \"â›…ï¸\"  \n  } else if (code == 803) {\n    return isNight ? \"â˜ï¸\" : \"ðŸŒ¥\" \n  } else if (code == 804) {\n    return \"â˜ï¸\"  \n  } else if (code == 900 || code == 962 || code == 781) {\n    return \"ðŸŒª\" \n  } else if (code >= 700 && code < 800) {\n    return \"ðŸŒ«\" \n  } else if (code == 903) {\n    return \"ðŸ¥¶\"  \n  } else if (code == 904) {\n    return \"ðŸ¥µ\" \n  } else if (code == 905 || code == 957) {\n    return \"ðŸ’¨\" \n  } else if (code == 906 || code == 958 || code == 959) {\n    return \"ðŸ§Š\" \n  } else {\n    return \"â“\" \n  }\n}\n\n\/\/-------------------------------------\n\/\/ Calendar Helper Functions\n\/\/-------------------------------------\n\n\/**\n * Fetch the next \"accepted\" calendar event from the given calendar\n * \n * @param {*} calendarName The calendar to get events from\n *\/\nasync function fetchNextCalendarEvent(calendarName) {\n  const calendar = await Calendar.forEventsByTitle(calendarName);\n  const events = await CalendarEvent.today([calendar]);\n  const tomorrow = await CalendarEvent.tomorrow([calendar]);\n\n  console.log(`Got ${events.length} events for ${calendarName}`);\n  console.log(`Got ${tomorrow.length} events for ${calendarName} tomorrow`);\n\n  const upcomingEvents = events\n    \/\/ .concat(tomorrow)\n    .filter(e => (new Date(e.endDate)).getTime() >= (new Date()).getTime())\n    \/\/ .filter(e => e.attendees && e.attendees.some(a => a.isCurrentUser && a.status === 'accepted'));\n\n  return upcomingEvents ? upcomingEvents[0] : null;\n}\n\n\/**\n * Given a calendar event, return the display text with title and time.\n * \n * @param {*} calendarEvent The calendar event\n * @param {*} isWorkEvent Is this a work event?\n *\/\nfunction getCalendarEventTitle(calendarEvent, isWorkEvent) {\n  if (!calendarEvent) {\n    return `No upcoming ${isWorkEvent ? 'work ' : ''}events`;\n  }\n\n  const timeFormatter = new DateFormatter();\n  timeFormatter.locale = 'en';\n  timeFormatter.dateFormat = \"HH:mm\";\n  \/\/timeFormatter.useNoDateStyle();\n  \/\/timeFormatter.useShortTimeStyle();\n\n  const eventTime = new Date(calendarEvent.startDate);\n\n  return `[${timeFormatter.string(eventTime)}] ${calendarEvent.title}`;\n}\n\n\/\/-------------------------------------\n\/\/ Misc. Helper Functions\n\/\/-------------------------------------\n\n\/**\n * Make a REST request and return the response\n * \n * @param {*} url URL to make the request to\n * @param {*} headers Headers for the request\n *\/\nasync function fetchJson(url, headers) {\n  try {\n    console.log(`Fetching url: ${url}`);\n    const req = new Request(url);\n    req.headers = headers;\n    const resp = await req.loadJSON();\n    return resp;\n  } catch (error) {\n    console.error(`Error fetching from url: ${url}, error: ${JSON.stringify(error)}`);\n  }\n}\n\n\/**\n * Get the last updated timestamp from the Cache.\n *\/\nasync function getLastUpdated() {\n  let cachedLastUpdated = await cache.read(CACHE_KEY_LAST_UPDATED);\n\n  if (!cachedLastUpdated) {\n    cachedLastUpdated = new Date().getTime();\n    cache.write(CACHE_KEY_LAST_UPDATED, cachedLastUpdated);\n  }\n\n  return cachedLastUpdated;\n}\n",
  "share_sheet_inputs" : [

  ]
}